package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage=null;
    private Iterator<Tuple> _innerPage=null;

    private Tuple _outerRecent=null;
    private Tuple _innerRecent=null;

    private TupleDesc tupleDesc = null;

    private int _joinType = 0;
    private int _numMatches =0;
    private int _numComp=0;

    public static final int SNL = 0;
    public static final int PNL = 1;
    public static final int BNL = 2;
    public static final int SMJ = 3;
    public static final int HJ = 4;
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        this._predicate = p;
        this._outerRelation = child1;
        this._innerRelation = child2;
    }

    public void setJoinAlgorithm(int joinAlgo){
        _joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
        return this.tupleDesc;
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
        this._outerRelation.open();
        this._innerRelation.open();

        Tuple outer = this._outerRelation.next();
        this._outerRelation.rewind();
        Tuple inner = this._innerRelation.next();
        this._innerRelation.rewind();

        TupleDesc td1 = outer.getTupleDesc();
        TupleDesc td2 = inner.getTupleDesc();

        this.tupleDesc = TupleDesc.combine(td1, td2);
    }

    public void close() {
        this._outerRelation.close();
        this._innerRelation.close();
        this._outerRecent=null;
        this._innerRecent=null;
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
        this._outerRelation.rewind();
        this._innerRelation.rewind();
        this._outerRecent=null;
        this._innerRecent=null;
        this._numMatches=0;
        this._numComp=0;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
        try {
            switch(_joinType){
                case SNL: return SNL_readNext();
                case PNL: return PNL_readNext();
                case BNL: return BNL_readNext();
                case SMJ: return SMJ_readNext();
                case HJ: return HJ_readNext();
                default: return SNL_readNext();
            }
        } catch(IOException e) {
            throw new DbException(e.getMessage());
        }
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException, IOException {
        Tuple ret = null;

        if(this._outerRecent == null && this._outerRelation.hasNext())
            this._outerRecent = this._outerRelation.next();

        while(this._outerRecent != null) {
            while(this._innerRelation.hasNext()) {
                Tuple inner = this._innerRelation.next();
                this._numComp++;
                if(this._predicate.filter(this._outerRecent, inner)) {
                    this._numMatches++;
                    return this.joinTuple(this._outerRecent, inner, this.getTupleDesc());
                }
            }
            this._innerRelation.rewind();
            this._outerRecent = (this._outerRelation.hasNext()) ? this._outerRelation.next() : null;
        }
        return null;
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
        //IMPLEMENT THIS (EXTRA CREDIT ONLY)
        return null;
    }


    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
        //no need to implement this
        return null;
    }


    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {

        //IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
        return null;
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
        //no need to implement this
        return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
        if(outer == null || inner == null || tupledesc == null)
            return null;
        Tuple t = new Tuple(tupledesc);
        int curr = 0;
        for (int i = 0; i < outer.getTupleDesc().numFields(); i++) {
            t.setField(curr, outer.getField(i));
            curr++;
        }
        for (int i = 0; i < inner.getTupleDesc().numFields(); i++) {
            t.setField(curr, inner.getField(i));
            curr++;
        }
        return t;

    }

    public int getNumMatches(){
        return _numMatches;
    }
    public int getNumComp(){
        return _numComp;
    }
}
